[{"title":"Webstrom个人设置","date":"2017-03-21T07:56:05.000Z","path":"2017/03/21/Webstrom个人设置/","text":"webstrom版本 2017.1 自用设置1.设置字体Source Code Pro 字体下载 下载好后安装在电脑 webstrom设置 Editor &gt; Colors &amp; Fonts &gt; font 里面设置Source Code Pro Semibold 字体 字体大小 Size：24 字体显示效果如下图 2.设置Monokai-Sublime主题颜色Monokai_Sublime下载链接 下载Monokai-Sublime.jar文件，在 webstorm 中 File &gt; Import File Location 导入下载的jar文件即可。 设置配色 Editor &gt; Colors &amp; Fonts 中选择Monokai-Sublime 3.设置f5快捷键在浏览器中打开点击菜单 files –》 settings –》在左侧菜单中 Appearance &amp;behavior 下面有一个keymap 点击–》在右侧搜索 open in default browser，并设置快捷键（会提示F5 快捷键冲突，请忽略）–》完成设置 4.设置CTRL+鼠标滚轮缩放字体 Editor-&gt;General，选择Change font size (Zoom) with Ctrl+Mouse Wheel 5.设置选中代码背景显示的颜色settings ==》 editor &gt; Colors &amp; Fonts &gt; General &gt; Selection background 中设置背景颜色 6.设置点击标签后高亮显示标签对的样式 settings ==&gt; editor &gt; Colors &amp; Fonts &gt; General &gt; Code &gt; Matched brace 里面设置背景和样式 不设置背景颜色显示为 7.设置鼠标双击单词。高亮显示相同单词settings ==》搜索Highlight Usages in File ==&gt; 增加鼠标点击快捷键","tags":[{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/tags/编辑器/"}]},{"title":"artTemplate 模板引擎","date":"2017-03-16T18:31:11.000Z","path":"2017/03/17/artTemplate/","text":"artTemplate-3.0新一代 javascript 模板引擎 目录 特性 快速上手 模板语法 下载 方法 NodeJS 使用预编译 更新日志 授权协议 特性 性能卓越，执行速度通常是 Mustache 与 tmpl 的 20 多倍（性能测试） 支持运行时调试，可精确定位异常模板所在语句（演示） 对 NodeJS Express 友好支持 安全，默认对输出进行转义、在沙箱中运行编译后的代码（Node版本可以安全执行用户上传的模板） 支持include语句 可在浏览器端实现按路径加载模板（详情） 支持预编译，可将模板转换成为非常精简的 js 文件 模板语句简洁，无需前缀引用数据，有简洁版本与原生语法版本可选 支持所有流行的浏览器 快速上手编写模板使用一个type=&quot;text/html&quot;的script标签存放模板： 12345678&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;ul&gt; &#123;&#123;each list as value i&#125;&#125; &lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125;&lt;/ul&gt;&lt;/script&gt; 渲染模板 123456var data = &#123; title: &apos;标签&apos;, list: [&apos;文艺&apos;, &apos;博客&apos;, &apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;]&#125;;var html = template(&apos;test&apos;, data);document.getElementById(&apos;content&apos;).innerHTML = html; 演示 模板语法有两个版本的模板语法可以选择。 简洁语法推荐使用，语法简单实用，利于读写。 1234567&#123;&#123;if admin&#125;&#125; &#123;&#123;include &apos;admin_content&apos;&#125;&#125; &#123;&#123;each list&#125;&#125; &lt;div&gt;&#123;&#123;$index&#125;&#125;. &#123;&#123;$value.user&#125;&#125;&lt;/div&gt; &#123;&#123;/each&#125;&#125;&#123;&#123;/if&#125;&#125; 查看语法与演示 原生语法 1234567&lt;%if (admin)&#123;%&gt; &lt;%include(&apos;admin_content&apos;)%&gt; &lt;%for (var i=0;i&lt;list.length;i++) &#123;%&gt; &lt;div&gt;&lt;%=i%&gt;. &lt;%=list[i].user%&gt;&lt;/div&gt; &lt;%&#125;%&gt;&lt;%&#125;%&gt; 查看语法与演示 下载 template.js (简洁语法版, 2.7kb) template-native.js (原生语法版, 2.3kb) 方法template(id, data)根据 id 渲染模板。内部会根据document.getElementById(id)查找模板。 如果没有 data 参数，那么将返回一渲染函数。 template.compile(source, options)将返回一个渲染函数。演示 template.render(source, options)将返回渲染结果。 template.helper(name, callback)添加辅助方法。 例如时间格式器：演示 template.config(name, value)更改引擎的默认配置。1234567字段 | 类型 | 默认值| 说明------------ | ------------- | ------------ | ------------openTag | String | ``&apos;&#123;&#123;&apos;`` | 逻辑语法开始标签closeTag | String | ``&quot;&#125;&#125;&quot;`` | 逻辑语法结束标签escape | Boolean | ``true`` | 是否编码输出 HTML 字符cache | Boolean | ``true`` | 是否开启缓存（依赖 options 的 filename 字段）compress | Boolean | ``false`` | 是否压缩 HTML 多余空白字符 使用预编译使用预编译可突破浏览器限制，让前端模板拥有后端模板一样的同步“文件”加载能力： 一、按文件与目录组织模板 1template(&apos;tpl/home/main&apos;, data) 二、模板支持引入子模板 12&#123;&#123;include &apos;../public/header&apos;&#125;&#125; 基于预编译： 可将模板转换成为非常精简的 js 文件（不依赖引擎） 使用同步模板加载接口 支持多种 js 模块输出：AMD、CMD、CommonJS 支持作为 GruntJS 插件构建 前端模板可共享给 NodeJS 执行 自动压缩打包模板 预编译工具：TmodJS NodeJS安装 1npm install art-template 使用 1234var template = require(&apos;art-template&apos;);var data = &#123;list: [&quot;aui&quot;, &quot;test&quot;]&#125;;var html = template(__dirname + &apos;/index/main&apos;, data); 配置NodeJS 版本新增了如下默认配置：12345字段 | 类型 | 默认值| 说明------------ | ------------- | ------------ | ------------base | String | ``&apos;&apos;`` | 指定模板目录extname | String | ``&apos;.html&apos;`` | 指定模板后缀名encoding | String | ``&apos;utf-8&apos;`` | 指定模板编码 配置base指定模板目录可以缩短模板的路径，并且能够避免include语句越级访问任意路径引发安全隐患，例如： 12template.config(&apos;base&apos;, __dirname);var html = template(&apos;index/main&apos;, data) NodeJS + Express 123456var template = require(&apos;art-template&apos;);template.config(&apos;base&apos;, &apos;&apos;);template.config(&apos;extname&apos;, &apos;.html&apos;);app.engine(&apos;.html&apos;, template.__express);app.set(&apos;view engine&apos;, &apos;html&apos;);//app.set(&apos;views&apos;, __dirname + &apos;/views&apos;); 运行 demo: 1node demo/node-template-express.js 若使用 js 原生语法作为模板语法，请改用 require(&#39;art-template/node/template-native.js&#39;) 升级参考为了适配 NodeJS express，artTemplate v3.0.0 接口有调整。 接口变更 默认使用简洁语法 template.render()方法的第一个参数不再是 id，而是模板字符串 使用新的配置接口template.config()并且字段名有修改 template.compile()方法不支持 id 参数 helper 方法不再强制原文输出，是否编码取决于模板语句 template.helpers 中的$string、$escape、$each已迁移到template.utils中 template()方法不支持传入模板直接编译 升级方法 如果想继续使用 js 原生语法作为模板语言，请使用 template-native.js 查找项目template.render替换为template 使用template.config(name, value)来替换以前的配置 template()方法直接传入的模板改用template.compile()（v2初期版本）","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"模板引擎","slug":"模板引擎","permalink":"http://yoursite.com/tags/模板引擎/"}]},{"title":"less预处理CSS","date":"2017-03-16T04:29:44.000Z","path":"2017/03/16/less/","text":"LessSass styuls 一款比较流行的预处理CSS，支持变量、混合、函数、嵌套、循环等特点官网中文网http://www.w3cplus.com/css/less 概要为什么要有预处理CSSCSS基本上是设计师的工具，不是程序员的工具。在程序员的眼里，CSS是很头痛的事情，它并不像其它程序语言，比如说PHP、Javascript等等，有自己的变量、常量、条件语句以及一些编程语法，只是一行行单纯的属性描述，写起来相当的费事，而且代码难易组织和维护。 很自然的，有人就开始在想，能不能给CSS像其他程序语言一样，加入一些编程元素，让CSS能像其他程序语言一样可以做一些预定的处理。这样一来，就有了“CSS预处器（CSS Preprocessor）”。 什么是预处理CSS CSS语言的超集，比CSS更丰满 CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。 CSS预处理器技术已经非常的成熟，而且也涌现出了很多种不同的CSS预处理器语言，比如说：Sass（SCSS）、LESS、Stylus、Turbine、Swithch CSS、CSS Cacheer、DT CSS等。如此之多的CSS预处理器，那么“我应该选择哪种CSS预处理器？”也相应成了最近网上的一大热门话题，在Linkedin、Twitter、CSS-Trick、知呼以及各大技术论坛上，很多人为此争论不休。相比过计我们对是否应该使用CSS预处理器的话题而言，这已经是很大的进步了。 到目前为止，在众多优秀的CSS预处理器语言中就属Sass、LESS和Stylus最优秀，讨论的也多，对比的也多。本文将分别从他们产生的背景、安装、使用语法、异同等几个对比之处向你介绍这三款CSS预处理器语言。相信前端开发工程师会做出自己的选择——我要选择哪款CSS预处理器。 如何使用预处理Lessless.js 网页运行阶段解析LESS文件 使用方式：less compiler 开发阶段编译LESS文件成为CSS 使用方式：安装 安装Node.js 安装less 命令行执行：npm install -g less 编译操作语法注释12// 模板注释，这里的注释转换成CSS后将会删除/* CSS 注释语法 转换为CSS后任然保留 */ 定义变量 将需要重复使用或经常修改的值定义为变量，需要使用的地方引用 less 1234567@变量名: 变量值;@bgColor: #f5f5f5;body&#123; width: @变量名; background-color: @bgColor;&#125; css 1234body&#123; width: 变量值; background-color: #f5f5f5;&#125; 嵌套 如果你在CSS中经常使用子代选择器，那LESS的嵌套语法使用起来非常Happy less 123456789101112131415161718.container &#123; width: @containerWidth; &gt; .row &#123; height: 100%; a&#123; color: #f40; &amp;:hover&#123; color: #f50; &#125; &#125; &#125; div &#123; width: 100px; .hello &#123; background-color: #00f; &#125; &#125;&#125; css 123456789101112131415161718.container &#123; width: 1024px;&#125;.container &gt; .row &#123; height: 100%;&#125;.container &gt; .row a &#123; color: #f40;&#125;.container &gt; .row a:hover &#123; color: #f50;&#125;.container div &#123; width: 100px;&#125;.container div .hello &#123; background-color: #00f;&#125; Mixin12345678910111213/* 定义一个类 */.roundedCorners(@radius: 5px) &#123; -moz-border-radius: @radius; -webkit-border-radius: @radius; border-radius: @radius;&#125;/* 定义的类应用到另个一个类中 */＃header &#123; .roundedCorners;&#125;#footer &#123; .roundedCorners(10px);&#125; Import 我们可以在开发阶段将样式放到多个文件中，最后通过@import 的方式合并 less 123456789101112// main.less@btnColor: red;@import url('_buttom.less');body&#123; width: 1024px;&#125;// _buttom.less.btn&#123; color: @btnColor;&#125; css 123456.btn&#123; color: red;&#125;body&#123; width: 1024px;&#125; 函数内置函数 lighten：将一个颜色变亮 lighten(#000, 10%); // #1a1a1a darken：将一个颜色变暗 darken(#000, 10%); // #e6e6e6 自定义函数等讲流行框架再说安装NodeJS","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"html5复习","date":"2017-03-12T04:27:46.000Z","path":"2017/03/12/HTML5/","text":"2015年12月03日Markdown 用普通文本描述富文本的语法扩展名md,markdown HTML5之HTML篇回顾 新标签 语义化标签 新属性 链接关系描述 ARIA 无障碍富互联网应用程序属性 自定义属性 data- 可以给HTML里的所有DOM对象都可以添加一些DATA-xxx的属性 用来记录与当前DOM强相关的数据 智能表单 新的表单类型 功能型的表单类型 虚拟键盘适配 通过type方式指定弹出键盘 网页多媒体 之前强依赖flash 音频 多媒体的dom对象有一些新的方法可以去做播放暂停 视频 了解字幕 SVG 文件基本使用 iframe iframe的作用就是在网页中挖个坑，在这个坑里再展示一个页面 svg本身也是文档 所以可以使用iframe的方式载入 ajax 直接可以修改样式 JavaScript2.1. 基础API提升2.1.1 新选择器JS多了一个原始支持，类似jqueryDOM选择器 document.getElementById() 需要给DOM元素设置IDdocument.querySelector(selector) 可以通过CSS选择器的语法找到DOM元素 document.getElementsByTagName()document.querySelectorAll(‘.item’) $(‘.item’).on document.querySelector(selector); 返回第一个满足选择器条件的元素 一个dom对象 document.querySelectorAll(‘.item’); 返回所有满足该条件的元素 一个元素类型是dom类型的数组 $(‘.item’) 返回一个jQuery对象（dom元素的数组） 本质上jquery方式和qs方式都是获取DOM数组， 只不过jquery会多一些其他成员 DOM数组的每一个成员注册事件不能像jquery一样直接注册， 必须分别给每个元素注册 h5就是将我们经常需要的操作又包装一层 2.1.2 元素.classList 新H5中DOM对象多了一个classList属性，是一个数组 add 添加一个新的类名 remove 删除一个的类名 contains 判断是否包含一个指定的类名 toggle 切换一个class element.toggle(‘class-name’,[add_or_remove]) toggle函数的第二个参数true为添加 false删除 2.1.3 访问历史 API界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态在HTML5中可以通过window.history操作访问历史状态，让一个页面可以有多个历史状态 window.history.forward(); // 前进 window.history.back(); // 后退 window.history.go(); // 刷新 通过JS可以加入一个访问状态 history.pushState(放入历史中的状态数据, 设置title(现在浏览器不支持)， 改变历史状态) 2.1.4 全屏 API JavaScript中可以通过调用requestFullScreen()方式实现指定元素的全屏显示var element = document.querySelector(‘…’);element.requestFullScreen(); 2.2 网页存储2.2.1 Web Storage getItem方式获取一个不存在的键 返回空字符串 []返回 undefined 2.2.2 Web SQL2.2.3 IndexedDB2.3 文件系统2.3.1 File API2.3.2 FileReader2.4 拖放操作2.4.1 网页内拖放2.4.2 文件拖入","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}]},{"title":"JQ复习","date":"2017-03-10T04:29:53.000Z","path":"2017/03/10/jQuery/","text":"1. jQuery是什么？(了解) www.github.com jQuery 其实就是一堆的js函数，是普通的js，只不过应用广泛，形成了行业标准。 参考书：锋利的jQuery 学习参考：http://www.w3school.com.cn/jquery/ 官网：http://jquery.com/ ##2. jQuery的重点 2.1 jQuery入口函数(全球都会) 2.2 jQuery的选择器(其实就是CSS的选择器) 2.3 jQuery的Dom操作 2.4 jQuery的样式操作 2.5 jQuery的动画 2.6 jQuery的事件处理 3.jQuery的入口函数 3.1 语法 jQuery(document).read(function(){ }); $(function(){ });// ** window.onlaod = function(){} $ === jQuery // $是jQuery全局函数的别名。 3.2注意事项： （重点） document ready: 是html文档准备就绪，也就是dom树创建完成了。可以进行dom操作了。重要的是：html页面下载完成，并准备就绪 window.onload: 是整个页面所有的资源都加载完成，图片、js、css等… 3.3 文档加载顺序： （重点） 下载html页面，解析html标签，遇到link标签加载css，遇到script加载js.. 4. jQuery 选择选取元素4.1 jQuery选择器 4.1.1 ID选择器（js一般尽量用ID选择器，效率最高） （重点） $(“#id”).html(); 4.1.2 类选择器 （重点） $(“.className”).text(); 4.1.3 标签选择器 （重点） $(‘p’).click(); 4.1.4 属性选择器 $(“li[id]”)、 $(“li[id=’link’]”).fadeIn(); 4.1.5 层级选择器 （重点） $(“li .link”).show(); 4.1.6 父子选择器 $(“ul &gt; li”) 4.1.7 伪类选择器 $(“p:first”) $(“ul li:eq(3)”) 4.1.8 表单选择器 $(“:text”) $(“:checkbox”) $(“:checked”) 4.2 选择器汇总12345* $(&quot;*&quot;) 所有元素#id $(&quot;#lastname&quot;) id=&quot;lastname&quot; 的元素.class $(&quot;.intro&quot;) 所有 class=&quot;intro&quot; 的元素element $(&quot;p&quot;) 所有 &lt;p&gt; 元素.class.class $(&quot;.intro.demo&quot;) 所有 class=&quot;intro&quot; 且 class=&quot;demo&quot; 的元素 1234:first $(&quot;p:first&quot;) 第一个 &lt;p&gt; 元素:last $(&quot;p:last&quot;) 最后一个 &lt;p&gt; 元素:even $(&quot;tr:even&quot;) 所有偶数 &lt;tr&gt; 元素:odd $(&quot;tr:odd&quot;) 所有奇数 &lt;tr&gt; 元素 1234567:eq(index) $(&quot;ul li:eq(3)&quot;) 列表中的第四个元素（index 从 0 开始）:gt(no) $(&quot;ul li:gt(3)&quot;) 列出 index 大于 3 的元素 greater than:lt(no) $(&quot;ul li:lt(3)&quot;) 列出 index 小于 3 的元素 less than:not(selector) $(&quot;input:not(:empty)&quot;) 所有不为空的 input 元素 :header $(&quot;:header&quot;) 所有标题元素 &lt;h1&gt; - &lt;h6&gt;:animated 所有动画元素 123456:contains(text) $(&quot;:contains(&apos;W3School&apos;)&quot;) 包含指定字符串的所有元素:empty $(&quot;:empty&quot;) 无子（元素）节点的所有元素:hidden $(&quot;p:hidden&quot;) 所有隐藏的 &lt;p&gt; 元素:visible $(&quot;table:visible&quot;) 所有可见的表格 s1,s2,s3 $(&quot;th,td,.intro&quot;) 所有带有匹配选择的元素 1234[attribute] $(&quot;[href]&quot;) 所有带有 href 属性的元素[attribute=value] $(&quot;[href=&apos;#&apos;]&quot;) 所有 href 属性的值等于 &quot;#&quot; 的元素[attribute!=value] $(&quot;[href!=&apos;#&apos;]&quot;) 所有 href 属性的值不等于 &quot;#&quot; 的元素[attribute$=value] $(&quot;[href$=&apos;.jpg&apos;]&quot;) 所有 href 属性的值包含以 &quot;.jpg&quot; 结尾的元素 12345678910:input $(&quot;:input&quot;) 所有 &lt;input&gt; 元素:text $(&quot;:text&quot;) 所有 type=&quot;text&quot; 的 &lt;input&gt; 元素:password $(&quot;:password&quot;) 所有 type=&quot;password&quot; 的 &lt;input&gt; 元素:radio $(&quot;:radio&quot;) 所有 type=&quot;radio&quot; 的 &lt;input&gt; 元素:checkbox $(&quot;:checkbox&quot;) 所有 type=&quot;checkbox&quot; 的 &lt;input&gt; 元素:submit $(&quot;:submit&quot;) 所有 type=&quot;submit&quot; 的 &lt;input&gt; 元素:reset $(&quot;:reset&quot;) 所有 type=&quot;reset&quot; 的 &lt;input&gt; 元素:button $(&quot;:button&quot;) 所有 type=&quot;button&quot; 的 &lt;input&gt; 元素:image $(&quot;:image&quot;) 所有 type=&quot;image&quot; 的 &lt;input&gt; 元素:file $(&quot;:file&quot;) 所有 type=&quot;file&quot; 的 &lt;input&gt; 元素 1234:enabled $(&quot;:enabled&quot;) 所有激活的 input 元素:disabled $(&quot;:disabled&quot;) 所有禁用的 input 元素:selected $(&quot;:selected&quot;) 所有被选取的 input 元素:checked $(&quot;:checked&quot;) 所有被选中的 input 元素 4.3 jQuery选择方法 4.3.1 获取父级元素 12* $(selector).parent(); //获取直接父级* $(selector).parents(&apos;p&apos;); //获取所有父级元素直到html 4.3.2 获取子代和后代的元素 123* $(selector).children(); //获取直接子元素* $(selector).find(&quot;span&quot;); //获取所有的后代元素* find方法 可能用的多。 4.3.3 获取同级的元素 12345* $(selector).siblings() //所有的兄弟节点* $(selector).next() //下一个节点* $(selector).nextAll() //后面的所有节点* $(selector).prev() //前面一个的兄弟节点* $(selector).prevAll() //前面的所有的兄弟节点 4.3.4 过滤方法 123456* $(&quot;div p&quot;).last(); //取最后一个元素* $(&quot;div p&quot;).first(); //取第一个元素* $(&quot;p&quot;).eq(1); //去第n个元素* $(&quot;p&quot;).filter(&quot;.intro&quot;); //过滤，选择所有p标签带有 .intro类$(&apos;p.intro&apos;)* $(&quot;p&quot;).not(&quot;.intro&quot;); //去除，跟上面的filetr正好相反 5.jQuery的Dom操作5.1 获取html的内容$(selector).text() - 设置或返回所选元素的文本内容 $(selector).html() - 设置或返回所选元素的内容（包括 HTML 标记） $(selector).val() - 设置或返回表单字段的值 获取和设置相同方法名,通过不同参数来确定是获取还是设置值 12$(&quot;#blin&quot;).text(&quot;传智播客&quot;);var txt = $(&quot;#blin&quot;).text(); 使用html来创建dom的方式效率比较高。 远大于： document.createElement(); 案例：02动态创建表格.html 5.2 样式操作 5.2.1 基本样式操作 1234567891011$(selector).css(&quot;color&quot;,&quot;red&quot;) |css(&#123;&#125;) 设置或返回匹配元素的样式属性。$(selector).height() 设置或返回匹配元素的高度。$(selector).offset().left =&gt; &#123; left:99, top: 22&#125; 返回第一个匹配元素相对于文档的位置。left,top$(selector).offsetParent() 返回最近的定位祖先元素。$(selector).position() 返回第一个匹配元素相对于父元素的位置。$(window).scrollLeft() 设置或返回匹配元素相对滚动条左侧的偏移。$(window).scrollTop(0) 设置或返回匹配元素相对滚动条顶部的偏移。&lt;!-- onscroll --&gt;$(selector).on(&quot;scroll&quot;,function()&#123;&#125;);$(selector).width() 设置或返回匹配元素的宽度。 5.2.2 样式类操作尽量操作样式类，少直接操作css属性 1234$(selector).addClass(&apos;class&apos;); 向匹配的元素添加指定的类名。$(selector).removeClass(&apos;class&apos;); 从所有匹配的元素中删除全部或者指定的类。$(selector).toggleClass(&apos;class&apos;) 从匹配的元素中添加或删除一个类。$(selector).hasClass(&apos;class&apos;) 检查匹配的元素是否拥有指定的类。 5.3 属性操作12$(selector).attr(&quot;id&quot;) 设置或返回匹配元素的属性和值$(selector).removeAttr()从所有匹配的元素中移除指定的属性。 5.4 动态创建12345678910$(selector).append() - 在被选元素的结尾插入内容 $(selector).append(node) $(selector).append(&apos;&lt;div&gt;&lt;/div&gt;&apos;) $(selector).appendTo(); - 追加到..$(selector).prepend() - 在被选元素的开头插入内容$(selector).after() - 在被选元素之后插入内容$(selector).before() - 在被选元素之前插入内容 案例04城市选择案例.html 6. 事件处理6.1 简单事件绑定方法 .click(hander) .click() //绑定事件 或者触发 click事件 .blur() //失去焦点事件，同上 .hover(mousein, mouseleave) //鼠标移入，移出 mouseout： 当鼠标离开元素及它的子元素的时都会触发。 mouseleave: 当鼠标离开自己时才会触发，子元素不触发。 .dbclick() 双击 change 改变,比如：文本框发送改变，下来列表发生改变等… focus 获得焦点 keyup, keydown, keypress : 键盘 键被按下。 mousedown, mouseover 6.2 绑定事件的方式 bind方式（不推荐，1.7以后的jQuery版本被on取代） 语法格式：.bind( eventType [, eventData ], handler ) 参数说明 第一个参数：事件类型 第二个参数：传递给事件响应方法的数据对象，可以省略。 事件响应方法中获取数据方式： e.data 第三个参数：事件响应方法第二个参数可以省略。 12345678例如： $(&quot;p&quot;).bind(&quot;click&quot;, function(e)&#123; //事件响应方法&#125;);$(&quot;p&quot;).on(&apos;click&apos;,function(e)&#123; //事件响应方法&#125;) 6.3 delegate方式（推荐，性能高，支持动态创建的元素）* 语法格式：$(selector).delegate( selector, eventType, handler ) * 语法说明： - 第一个参数:selector， 子选择器 - 第二个参数：事件类型 - 第三个参数：事件响应方法 12345678例如： $(&quot;.parentBox&quot;).delegate(&quot;p&quot;, &quot;click&quot;, function()&#123; //为 .parentBox下面的所有的p标签绑定事件&#125;);$(&quot;.parentBox&quot;).on(&quot;click&quot;,&quot;p&quot;, function()&#123; //为 .parentBox下面的所有的p标签绑定事件&#125;); *优势：效率较高* 6.4 one绑定一次事件的方式* .one( events [, data ], handler ) 12345678例如：$( &quot;p&quot; ).one( &quot;click&quot;, function() &#123; alert( $( this ).text() );&#125;);$(&quot;p&quot;).on(&quot;click&quot;,function()&#123; $(this).off(&apos;click&apos;);//事件方法执行了一次后，就立即解绑事件&#125;) 6.5 on绑定的方式（整合了bind、delegate 烈建议使用的方式）） jQuery1.7版本后，jQuery用on统一了所有的事件处理的方法 语法格式：$(selector).on( events [, selector ] [, data ], handler ) 参数介绍： 第一个参数：events，事件名 第二个参数：selector,类似delegate 第三个参数: 传递给事件响应方法的参数 第四个参数：handler，事件处理方法123456789101112131415161718192021例如：//绑定一个方法$( &quot;#dataTable tbody tr&quot; ).on( &quot;click&quot;, function() &#123; console.log( $( this ).text() );&#125;);//给子元素绑定事件$( &quot;#dataTable tbody&quot; ).on( &quot;click&quot;, &quot;tr&quot;, function() &#123; console.log( $( this ).text() );&#125;);//绑定多个事件的方式$( &quot;div.test&quot; ).on(&#123; click: function() &#123; $( this ).toggleClass( &quot;active&quot; ); &#125;, mouseenter: function() &#123; $( this ).addClass( &quot;inside&quot; ); &#125;, mouseleave: function() &#123; $( this ).removeClass( &quot;inside&quot; ); &#125;&#125;); 6.6 解绑 unbind解绑 bind方式绑定的事件( 在jQuery1.7以上被 on和off代替) $(selector).unbind(); //解绑所有的事件 $(selector).unbind(“click”); //解绑指定的事件 undelegate解绑delegate事件 $( “p” ).undelegate(); //解绑所有的delegate事件 $( “p” ).undelegate( “click” ); //解绑所有的click事件 off解绑on方式绑定的事件 $( “p” ).off(); $(“P”).off(‘click’); $( “p” ).off( “click”, “*” ); // 解绑所有的click事件，两个\\表示所有 $( “body” ).off( “click”, “p”, foo ); 6.7 触发事件 6.7.1 简单事件触发 $(selector).click(); //触发 click事件 6.7.2 trigger方法触发事件 $( “#foo” ).trigger( “click” ); 6.7.3 triggerHandler触发 事件响应方法，不触发浏览器行为 $( “input” ).triggerHandler( “focus” ); 6.8 event对象的简介 event.data //传递的额外事件响应方法的额外参数 event.currentTarget === this //在事件响应方法中等同于this，当前Dom对象 event.target //事件触发源，不一定===this event.pageX //The mouse position relative to the left edge of the document event.pageY event.stopPropagation()//阻止事件冒泡 e.preventDefault(); //阻止默认行为 event.type //事件类型：click，dbclick… event.which //鼠标的按键类型：左1 中2 右3 keydown : a,b,c event.keyCode// code的c是大写 7. jQuery动画系统7.1隐藏显示* $(selector).show(speed,callback); * $(selector).hide(1000); * $(selector).toggle(&quot;slow&quot;); * 三个方法的语法都一致，参数可以有两个，第一个是动画的速度，第二个是动画执行完成后的回调函数。 * 第一个参数是：可以是单词或者毫秒数 7.2淡入淡出$(selector).fadeIn(speed, callback) $(selector).fadeOut(1000) $(selector).fadeToggle(&apos;fast&apos;,function(){}) 参数等同于 7.1 * $(selector).fadeTo(.5); //淡入到 0透明，1不透明 7.3滑动* $(selector).slideDown(speed,callback); * $(selector).slideUp(speed,callback); * $(selector).slideToggle(speed,callback); 7.4动画* $(selector).animate({params},speed,callback); 12345678$(&quot;button&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123; left:&apos;250px&apos;, opacity:&apos;0.5&apos;, height:&apos;150px&apos;, width:&apos;150px&apos; &#125;,2000);&#125;).animate(&#123;&#125;,1000); 7.5结束动画* $(selector).stop() * $(selector).stop(stopAll,goToEnd); 案例： 8. jQuery补充 8.1 each函数 全局的 $.each(array, function(index, object){}) 普通jQuery对象的each方法 $(“li”).each(function(index, element){} ) 参数的顺序是一致的。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"写博客、发布文章","date":"2017-03-05T20:09:50.000Z","path":"2017/03/06/写博客、发布文章/","text":"写博客、发布文章1.转到hexo当前地址如：E： &gt; cd hexo2.新建一篇博客，执行下面的命令：1hexo new post &quot;article title&quot; 这时候在我的 电脑的目录下 E:\\hexo\\source_posts 将会看到 article title.md 文件 用MarDown编辑器打开就可以编辑文章了。 在MarDown中写more可以折叠代码。只显示一部分1&lt;!--more--&gt; 4.文章编辑好之后，运行生成、部署命令：12hexo g // 生成hexo d // 部署 或者执行 1hexo d -g #在部署前先生成","tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"2017年3月6日 04:25:30创建","date":"2017-03-05T18:09:50.000Z","path":"2017/03/06/article-title1/","text":"你好，欢迎来到我的个人技术博客。hello world!","tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/记录/"}]}]